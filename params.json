{
  "name": "Classfactory",
  "tagline": "Create class objects by names",
  "body": "﻿# ClassFactory\r\n\r\n1. About\r\n2. Requirements\r\n3. Instructions\r\n4. Usage\r\n\r\n##1. About\r\nThis library provides an easy to use interface in order to create class objects during runtime by simply passing a string which is assigned as a classname beforehand.  \r\nNow you may ask yourself how this could come in handy. Well, here are some reasons to use this library:  \r\n- You can pass requested objects from external resources (files, databases, ...) directly to an interface which will build the objects, no need for bloating your code with `if/else` statements\r\n- Using this library is ridiculously easy. You need a total of `2` lines of code to add classes to the factory and `1 ` line is enough to construct objects from it.\r\n- The library does not have any dependencies. Your compiler only has to support C++11\r\n- Since you are using C++ you are obviously the master race in terms of programming languages. You are laughing about these dirty peasents which are using languages like Java. But then you realize, these dirty peasents have class reflection to work with and you don't. Well, this library does not add it to C++, but at least it enables you to create objects by their class names, which is a cool part of the class reflection\r\n\r\n##2. Requirements\r\n- C++11 compatible compiler\r\n- CMake with version ≥ 2.8.12\r\n\r\n##3. Instructions\r\n\r\n- Download the source (via zip or by cloning this repo)\r\n- Create a directory in which the build-files will be placed\r\n- Run CMake for a compiler of your choice. If you wish you can enable the compilation of the example-project\r\n- Compile with your chosen compiler\r\n- The static library (and the example if enabled) will be placed under `YOUR_BUILD_DIR/bin/`\r\n- To use the library in your projects, link against this library and add `LIBRARY_SOURCE_DIR/include/` to your include path or add the header files directly to your project\r\n\r\n##4. Usage\r\nEverything you need you will find in the header file `LCF.h`  \r\nIf you want to build an object of a simple single class (e.g. Superclass), you have to use following definitions:  \r\n`FACTORY_REGISTER_SUPER_CLASS(Super)` inside your class and  \r\n`FACTORY_FINISH_SUPER_REGISTRATION(Super, Name)` outside of your class  \r\nIf you have a bit more complex class-hierarchy (using derivations), you have to add a typedef inside your superclass:  \r\n`typdef MySuperClass Super;` is what you need to add (in the protected scope of the class) in order to ensure that following definitions will work properly:  \r\n`FACTORY_REGISTER_DERIVATED_CLASS(Derivated)` inside of your derivated class  \r\n`FACTORY_FINISH_DERIVATED_REGISTRATION(Derivated, Name)` outside of your derivated class  \r\nFrom now on, you can build your specified classes with calling `sClassFactory->Alloc<Super>(Name);`  \r\nThis will return an `std::unique_ptr<Super>` which points to the object specified by `Name`  \r\n**Objects of derivated classes will be casted to their respective superclasses!**\r\n  \r\nSome Notes:  \r\n- `Name` (above) means nothing else than a string with which you can access your registrated classes\r\n- The registrations are **not** mutually exclusive, means you can register both Super and Derivated-Class(es)\r\n- An empty pointer is returned if you:\r\n - Allocated a class object with an unknown name or which is not registered\r\n - Allocated a class object and requesting T as superclass when in reality the superclass of the target object is U\r\n- So to make sure that you pointer is valid, just quickly check it with `if(your_pointer)`\r\n- Make sure that you don't register an abstract class (a class which does not implement at least one pure virtual function), else you would imply that this class can be instantiated which is, of course, not true and will result in an error during compiling\r\n- You can find an [example in the source](https://github.com/XaTToN/ClassFactory/blob/master/src/example/main.cpp)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}